name: Azure Pipelines

trigger:
- main

pool:
  name: myAgentPool

variables:
  # === أساسيات ===
  python.version: '3.7.6'
  azureServiceConnectionId: 'udacity-az-sp'
  projectRoot: '$(System.DefaultWorkingDirectory)'
  environmentName: 'test'

  # === Terraform backend ===
  backendResourceGroup: 'Azuredevops'
  backendStorageAccount: 'tfstatebootstrap01'
  backendContainer: 'tfstate'
  backendKey: 'test.terraform.tfstate'

  # App Service ثابت
  fixedAppName: 'myapp-AppService-131'

  # === أسماء الموارد القديمة التي ظهرت في اللوج ===
  legacyResourceGroup: 'Azuredevops1-test-new'
  legacyPrefix: 'myApplication1-20250907'   # أساس التسمية لكل الموارد القديمة

stages:
#--------------------------------------------#
# BUILD STAGE
#--------------------------------------------#
- stage: Build
  displayName: Build
  jobs:
  - job: BuildInfrastructure
    displayName: 'Terraform + Postman + Packaging'
    steps:
    - task: ms-devlabs.custom-terraform-tasks.custom-terraform-installer-task.TerraformInstaller@0
      displayName: 'Terraform installation'
      inputs:
        terraformVersion: '1.13.1'

    # احصل على Storage Account Key وفعّل الحاوية
    - task: AzureCLI@2
      displayName: 'Get tfstate access key'
      inputs:
        azureSubscription: '$(azureServiceConnectionId)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e
          KEY=$(az storage account keys list \
                -g "$(backendResourceGroup)" \
                -n "$(backendStorageAccount)" \
                --query "[0].value" -o tsv)
          echo "##vso[task.setvariable variable=ARM_ACCESS_KEY;issecret=true]$KEY"
          az storage container create \
            --name "$(backendContainer)" \
            --account-name "$(backendStorageAccount)" \
            --account-key "$KEY" \
            --auth-mode key >/dev/null || true
          echo "Backend key captured and container ensured."

    # Terraform init + validate عبر CLI
    - bash: |
        set -e
        cd "$(System.DefaultWorkingDirectory)/terraform/environments/test"
        terraform --version
        terraform init \
          -backend-config="storage_account_name=$(backendStorageAccount)" \
          -backend-config="container_name=$(backendContainer)" \
          -backend-config="key=$(backendKey)" \
          -backend-config="resource_group_name=$(backendResourceGroup)" \
          -backend-config="access_key=${ARM_ACCESS_KEY}"
        terraform validate
      displayName: 'Terraform init & validate (CLI)'
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)

    # ======= Auto-Import لكل الموارد الموجودة مسبقًا =======
    - task: AzureCLI@2
      displayName: 'Terraform auto-import existing Azure resources'
      inputs:
        azureSubscription: '$(azureServiceConnectionId)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e
          cd "$(System.DefaultWorkingDirectory)/terraform/environments/test"

          # دالة: استورد لو مو موجود في الستيت
          imp() {
            local addr="$1" id="$2"
            if terraform state show "$addr" >/dev/null 2>&1; then
              echo "[SKIP] $addr already in state"
            elif [ -n "$id" ]; then
              echo "[IMPORT] $addr  <=  $id"
              terraform import -input=false "$addr" "$id" || true
            fi
          }

          SUB_ID=$(az account show --query id -o tsv)
          RG='$(legacyResourceGroup)'
          PFX='$(legacyPrefix)'

          # RG
          RGID="/subscriptions/${SUB_ID}/resourceGroups/${RG}"
          imp 'module.resource_group.azurerm_resource_group.test' "$RGID"

          # Service Plan
          PLANID=$(az resource show -g "$RG" -n "${PFX}-AppService" \
                   --resource-type Microsoft.Web/serverFarms --query id -o tsv || true)
          imp 'module.appservice.azurerm_service_plan.test' "$PLANID"

          # Web App (لو كان موجود)
          WEBID=$(az resource show -g "$RG" -n "${PFX}-AppService" \
                  --resource-type Microsoft.Web/sites --query id -o tsv || true)
          imp 'module.appservice.azurerm_linux_web_app.test' "$WEBID"

          # VNet
          VNETID=$(az resource show -g "$RG" -n "${PFX}-NET" \
                   --resource-type Microsoft.Network/virtualNetworks --query id -o tsv || true)
          imp 'module.network.azurerm_virtual_network.test' "$VNETID"

          # Subnet
          SUBNETID=$(az network vnet subnet show -g "$RG" \
                     --vnet-name "${PFX}-NET" -n "${PFX}-NET-sub" \
                     --query id -o tsv || true)
          imp 'module.network.azurerm_subnet.test' "$SUBNETID"

          # NSG
          NSGID=$(az resource show -g "$RG" -n "${PFX}-NSG" \
                  --resource-type Microsoft.Network/networkSecurityGroups --query id -o tsv || true)
          imp 'module.nsg-test.azurerm_network_security_group.nsg' "$NSGID"

          # Association (Subnet <-> NSG) — صيغة import بـ pipe "|"
          if [ -n "$SUBNETID" ] && [ -n "$NSGID" ]; then
            imp 'module.nsg-test.azurerm_subnet_network_security_group_association.test' "${SUBNETID}|${NSGID}"
          fi

          # Public IP
          PUBID=$(az resource show -g "$RG" -n "${PFX}-publicip-pubip" \
                  --resource-type Microsoft.Network/publicIPAddresses --query id -o tsv || true)
          imp 'module.publicip.azurerm_public_ip.test' "$PUBID"

          echo "=== Current TF state ==="
          terraform state list || true
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)
    # ===============================================

    # الآن apply يمشي بدون تعارض "already exists"
    - bash: |
        set -e
        cd "$(System.DefaultWorkingDirectory)/terraform/environments/test"
        terraform apply -auto-approve
      displayName: 'Terraform apply (CLI)'
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)

    # ---------- Postman ----------
    - task: CmdLine@2
      displayName: 'Install Newman'
      inputs:
        script: 'npm install -g newman'
        workingDirectory: '$(System.DefaultWorkingDirectory)'

    - task: CmdLine@2
      displayName: 'Run Data Validation Tests'
      continueOnError: true
      inputs:
        script: 'newman run TestSuite.Data-Validation.json -e Test.environment.json --reporters cli,junit --reporter-junit-export TEST-DataValidation.xml'
        workingDirectory: '$(System.DefaultWorkingDirectory)/automatedtesting/postman'

    - task: CmdLine@2
      displayName: 'Run Regression Tests'
      continueOnError: true
      inputs:
        script: 'newman run TestSuite.Regression.json -e Test.environment.json --reporters cli,junit --reporter-junit-export TEST-Regression.xml'
        workingDirectory: '$(System.DefaultWorkingDirectory)/automatedtesting/postman'

    - task: PublishTestResults@2
      displayName: 'Publish Postman JUnit Results'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/TEST-*.xml'
        searchFolder: '$(System.DefaultWorkingDirectory)/automatedtesting/postman'
        mergeTestResults: true
        testRunTitle: 'Postman Results'

    # ---------- Selenium package ----------
    - task: ArchiveFiles@2
      displayName: 'Archive UI Tests (Selenium)'
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)/automatedtesting/selenium'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/$(Build.BuildId)-uitests.zip'
    - publish: '$(Build.ArtifactStagingDirectory)/$(Build.BuildId)-uitests.zip'
      displayName: 'Publish UI Tests Artifact'
      artifact: 'drop-uitests'

    # ---------- FakeRestAPI package ----------
    - task: ArchiveFiles@2
      displayName: 'Archive FakeRestAPI'
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)/automatedtesting/jmeter/fakerestapi'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/$(Build.BuildId)-fakerestapi.zip'
    - publish: '$(Build.ArtifactStagingDirectory)/$(Build.BuildId)-fakerestapi.zip'
      displayName: 'Publish FakeRestAPI Artifact'
      artifact: 'drop-fakerestapi'

    # ---------- JMeter package ----------
    - task: ArchiveFiles@2
      displayName: 'Archive PerformanceTestSuite (JMeter)'
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)/automatedtesting/jmeter'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/$(Build.BuildId)-perftests.zip'
    - publish: '$(Build.ArtifactStagingDirectory)/$(Build.BuildId)-perftests.zip'
      displayName: 'Publish Perf Tests Artifact'
      artifact: 'drop-perftests'

#--------------------------------------------#
# DEPLOYMENT STAGE
#--------------------------------------------#
- stage: Deploy
  displayName: Deploy
  dependsOn: Build
  jobs:
  - deployment: FakeRestAPI
    displayName: 'Deploy FakeRestAPI Web App'
    pool:
      name: 'myAgentPool'
    environment: '$(environmentName)'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Pre-config runtime & logging'
            inputs:
              azureSubscription: '$(azureServiceConnectionId)'
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                set -e
                RG='$(backendResourceGroup)'
                APP='$(fixedAppName)'
                az webapp config set -g "$RG" -n "$APP" --linux-fx-version "NODE|18-lts" || true
                az webapp config appsettings set -g "$RG" -n "$APP" --settings WEBSITE_NODE_DEFAULT_VERSION="~18" SCM_DO_BUILD_DURING_DEPLOYMENT=true WEBSITES_PORT=3000 >/dev/null
                az webapp log config -g "$RG" -n "$APP" --application-logging filesystem --level information --detailed-error-messages true --failed-request-tracing true >/dev/null || true

          - task: AzureWebApp@1
            displayName: 'Deploy Azure Web App (Zip)'
            inputs:
              azureSubscription: '$(azureServiceConnectionId)'
              appType: webApp
              appName: '$(fixedAppName)'
              package: '$(Pipeline.Workspace)/drop-fakerestapi/$(Build.BuildId)-fakerestapi.zip'

          - task: PowerShell@2
            displayName: 'Run JMeter against App Service'
            inputs:
              targetType: 'inline'
              script: |
                $perfFolder = Join-Path "$(Pipeline.Workspace)" "perftests"
                if (-Not (Test-Path $perfFolder)) { New-Item -ItemType Directory -Path $perfFolder | Out-Null }
                Set-Location $perfFolder
                $jmeterUrl = "https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-5.2.1.tgz"
                $jmeterTgz = Join-Path $perfFolder "apache-jmeter-5.2.1.tgz"
                Invoke-WebRequest -Uri $jmeterUrl -OutFile $jmeterTgz
                tar -xf $jmeterTgz
                $zipFile = Join-Path "$(Pipeline.Workspace)\drop-perftests" "$(Build.BuildId)-perftests.zip"
                if (Test-Path $zipFile) { Expand-Archive -Path $zipFile -DestinationPath $perfFolder -Force } else { Write-Error "Zip not found"; exit 1 }
                $jmeterExe = Join-Path $perfFolder "apache-jmeter-5.2.1\bin\jmeter.bat"
                $jmx1 = Join-Path $perfFolder "Starter.jmx"
                $jmx2 = Join-Path $perfFolder "PerformanceTestSuite.jmx"
                $jmxFile = (Test-Path $jmx1) ? $jmx1 : $jmx2
                if (-Not (Test-Path $jmxFile)) { Write-Error "JMX not found"; exit 1 }
                $logFile = Join-Path $perfFolder "jmeter.log"
                & $jmeterExe -n -t $jmxFile -j $logFile -f
                Get-Content $logFile -Tail 200

  - deployment: VMDeploy
    displayName: 'Selenium Tests'
    environment:
      name: '$(environmentName)'
    pool:
      name: 'myAgentPool'
      resourceType: VirtualMachine
      tags: selenium
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop-uitests

          - task: PowerShell@2
            displayName: 'Run Selenium Tests on Windows'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Installing dependencies..."
                pip install selenium
                $testFolder = "$(Pipeline.Workspace)\uitests"
                if (-Not (Test-Path $testFolder)) { New-Item -ItemType Directory -Path $testFolder | Out-Null }
                Expand-Archive "$(Pipeline.Workspace)\drop-uitests\$(Build.BuildId)-uitests.zip" -DestinationPath $testFolder -Force
                $chromeDriverPath = "C:\Users\Public\chromedriver\chromedriver.exe"
                if (-Not (Test-Path $chromeDriverPath)) {
                  $latest = Invoke-RestMethod "https://chromedriver.storage.googleapis.com/LATEST_RELEASE"
                  $zip = "$testFolder\chromedriver_win32.zip"
                  Invoke-WebRequest "https://chromedriver.storage.googleapis.com/$latest/chromedriver_win32.zip" -OutFile $zip
                  New-Item -ItemType Directory -Path (Split-Path $chromeDriverPath) -Force | Out-Null
                  Expand-Archive $zip -DestinationPath (Split-Path $chromeDriverPath) -Force
                }
                $env:PATH += ";" + (Split-Path $chromeDriverPath) + ";$testFolder"
                python "$testFolder\add_remove_from_cart.py" | Tee-Object -FilePath "$testFolder\selenium.log"
                Write-Host "Completed Selenium Tests."
